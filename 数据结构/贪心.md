##  贪心

贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。贪心算法不是对所有问题都能得到整体最优解，但对范围相当广泛的许多问题他能产生整体最优解或者是整体最优解的近似解。


我觉得人认为：**如果找出局部最优并可以推出全局最优，就是贪心。**

### 吃火锅

####  题目描述
入职后，导师会请你吃饭，你选择了火锅。

火锅里会在不同时间下很多菜。

不同食材要煮不同的时间，才能变得刚好合适。

你希望吃到最多的刚好合适的菜，但你的手速不够快，用m代表手速，每次下手捞菜后至少要过m秒才能再捞（每次只能捞一个）。

那么用最合理的策略，最多能吃到多少刚好合适的菜？

#### 输入描述

第一行两个整数n，m，其中n代表往锅里下的菜的个数，m代表手速。（1 < n, m < 1000）

接下来有n行，每行有两个数x，y代表第x秒下的菜过y秒才能变得刚好合适。（1 < x, y < 1000）

#### 输出描述

输出一个整数代表用最合理的策略，最多能吃到刚好合适的菜的数量。


例如吃火锅这道题， 如果我们按照菜熟的时间进行排序， 尽可能的夹多的菜，只要我们cd时间到了就夹，这样就是考虑的局部最优。详细理由如下：

实际上可以通过排序和简单的循环来直接计算最优解。将所有合适吃的菜按照时间排序，然后从第一个菜开始，逐步遍历，只要满足时间间隔，就可以直接计数，不需要额外的复杂状态维护。

- 我们首先对所有菜按它们刚好合适吃的时间点进行升序排序。这种排序保证了我们可以从最早的合适的菜开始考虑，这样后续的每次捞菜都能够最大限度地利用前面的时间，从而不浪费任何一个合适的菜。

- 因为菜的合适时间点是固定的，且捞菜后需要等待 m 秒才能捞下一道菜，因此，如果第一个合适的菜和第二个合适的菜之间的时间间隔小于 m，那么无论你选择先捞哪个菜，都无法在规定的时间内同时捞到两个菜。这意味着，如果我们不先捞第一个合适的菜，就有可能错过它，而开始从第二个菜捞起，这样并不会增加捞菜的数量，反而可能浪费机会。

- 为了简化操作，我们直接选择第一个合适的必捞。如果不捞第一个合适的菜，那么后续的决策会变得复杂，因为要考虑什么时候开始捞，可能会错失一些机会。为了简化操作且保证不浪费任何机会，直接从第一个合适的菜开始捞是最优的策略。

```JS

const readyTimes = [];
    for (let i = 1; i <= n; i++) {
        const [x, y] = input[i].split(' ').map(Number); // 读取每道菜的下锅时间x和煮熟时间y
        readyTimes.push(x + y); // 计算并存储合适的时间
    }
readyTimes.sort((a, b) => a - b); // 对所有菜的合适时间进行排序

let count = 1; // 记录最多能捞到的菜数，第一个菜必捞
let lastTime = readyTimes[0]; // 记录上次捞菜的时间

for(let i = 1; i<readyTimes.length;i++) {
    if(lastTime + m<=readyTimes[i]) {
        lastTime = readyTimes[i]
        count+=1
    }
}

```




