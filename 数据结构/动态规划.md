70. 爬楼梯(很经典的一道动态规划题)
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

```
假如爬1楼： 1种 ， 2楼： 2种， 3楼： 3种 (爬2楼的种数+爬1楼的种数)

可以推导出 d(n) = d(n-1) + d(n-2)

```


746. 使用最小花费爬楼梯
给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费

示例 1：
```
输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。
```

```

minSumCost(i) = min(minSumcost(i-2),minSumCost(i-1))+cost[i]

minSumCost = [10,15,30]

return min(-2, -1)
```

1. 跳跃游戏

给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。示例 1：

输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
示例 2：

输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。

---------------

只要判断当前距离是否能达到 加上 本身值  大于后面的索引值即可 即可。
那么如何判断当前距离是否可以达到?例如 nums[2] 等于 nums[1] + nums[1]是否可达到 > 2(索引值)

```
let k = 0
if(let i = 0;i<nums.length;i++){
    if(k < i) return false
    k = Math.max(k, k + nums[i]) 
}
```

尽可能到达最远位置（贪心）。 如果能到达某个位置，那一定能到达它前面的所有位置。


###  动态规划 + 二分查找优化（Python/Java/C++/Go/JS/Rust）


1. leetcode 2008. 出租车的最大盈利

2. leetcode 1235. 规划兼职工作

```
for(let i = 1; i<arr.length; i++){
    const j = binarySearch(i, target)
    dp[i] = Math.max(dp[i], dp[i-arr[j]])
}

const binarySearch = (i,)=>{
    let left = 0
    let right i
    while(left < right) {
        const mid = Math.floor(left + right /2)
        if(arr[mid] < target) {
            left= mid
        } else {
            right = mid-1
        }
    }

    return left
}


```

算法小课堂：标准库二分的灵活运用
在写二分题目时，经常会遇到形如「在有序数组中查询大于某个数的最小数」这类问题。具体来说有四类：

≥：在有序数组中查询大于或等于某个数的最小数；
>：在有序数组中查询大于某个数的最小数；
≤：在有序数组中查询小于或等于某个数的最大数；
<：在有序数组中查询小于某个数的最大数。
上面的一些编程语言用到了标准库中的二分，但这些二分在设计的时候，只提供了查询≥和>的功能，并没有提供查询≤和<的功能。

没有关系，稍微转换下就能解决。比如查询>得到了下标i，那么i−1就是≤的结果了（假设数组为升序），同理<可以用≥算出来。

注：>和≥也可以转换，对于整数来说，>x等价于≥x+1。

