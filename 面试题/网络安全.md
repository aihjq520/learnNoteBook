### sql注入
#### 1.1简单注入
1. 数值型注入方式：例如我们后台有这样一个查询sql: 
SELECT * from user_info WHERE id= 
那么我们可以通过修改前端的值位：-1 or 1=1 来实现查询所有的数据，其中-1表示永远不可能存在的数据。
2. 字符串注入的方式：通过注释字符实现绕道
由于# / --通常标识注释，因此可以在输入用户名的时候加上’#，然后输入任意的密码，这样后面查询密码的sql 被注释掉，直接绕过密码校验实现登录；

因此要保证前后台输入框格式的绝对校验。另外严格禁止sql拼接，必须使用占位符

### 2.XSS攻击
跨站脚本攻击，是代码注入的一种，它允许恶意用户将代码注入到网页，其他用户在浏览网页时就会受到影响；将用户输入的数据当作了html语句放到了页面上执行

#### 2.1反射性XSS攻击
#### 2.2存储性XSS攻击
1. 假设这是一个交流论坛，其中一个页面中有留言的文本输入框，我们将具有攻击性的脚本写到文本框中，然后提交到服务端。（该脚本的含义表示，获取客户端的cookie，并发送到指定地址）。

2. 后台服务已经将我们提交的数据存储到数据库中。当其他用户在自己计算机中登陆这个网站的时候，服务端会将我们之前写入具有攻击性的XSS脚本留言渲染到HTML页面，从而将该用户页面中的cookie信息发送到我们预留的网站中。
3.接下来，我们就可以用这个人的cookie信息在该网站中“替代”他进行一系列的操作；一个简单的存储型XSS攻击(cookie欺骗)就完成。

针对js获取cookie的解决方案：在cookie中设置了HttpOnly属性为true，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击
#### 2.3 XSS攻击的防御措施
1. 转义html:  常用的模板引擎，如 doT.js、ejs、FreeMarker 等，对于 HTML 转义通常只有一个规则，就是把 & < > " ' / 这几个字符转义掉，确实能起到一定的 XSS 防护作用
2. 过滤：在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等。如果用 Vue或者React技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患。DOM 中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等，<a> 标签的 href 属性，JavaScript 的 eval()、setTimeout()、setInterval() 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。


### CSRF（Cross-site request forgery）跨站请求伪造
攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的