1.手写new

```javascript
function A(){}

function New(fn,...arguments){
    let newObj = {}
    if (fn.prototype !== null) {
        newObj.__proto__ = fn.prototype;
    }
    let ret = fn.apply(newObj,[...arguments].slice(1))
    if ((typeof ret === "object" || typeof ret === "function") && ret !== null) {
        return ret;
    }
    return newObj;
}
```

2.call和apply
let foo = {val:1}
function bar(){
    console.log(this.val)
}
我们模拟的步骤可以分为：
将函数设为对象的属性
执行该函数
删除该函数

Function.prototype.call2 =function(context = window,...rest:string[]){
    let ctx = context || window
    let func = Symbol()
    ctx[func] = this
    rest = rest ? rest : []
    context.fn(...rest)
    delete context.fn
}

3.1 bind
Function.prototype.myBind = function(context || window,...rest){
    let ctx = context || window
    let fn = Symbol()
    function bind(){
        ctx[fn](...rest)
    }

    return bind
}

4.继承

5.防抖节流
本质上是优化高频率执行代码的一种手段
如：浏览器的 resize、scroll、keypress、mousemove 等事件在触发时，会不断地调用绑定在事件上的回调函数，极大地浪费资源，降低前端性能

为了优化体验，需要对这类事件进行调用次数的限制，对此我们就可以采用 防抖（debounce） 和 节流（throttle） 的方式来减少调用频率

#定义

节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效

防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时

相同点：

都可以通过使用 setTimeout 实现
目的都是，降低回调执行频率。节省计算资源
不同点：

函数防抖，在一段连续操作结束后，处理回调，利用clearTimeout和 setTimeout实现。函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能
函数防抖关注一定时间连续触发的事件，只在最后执行一次，而函数节流一段时间内只执行一次
例如，都设置时间频率为500ms，在2秒时间内，频繁触发函数，节流，每隔 500ms 就执行一次。防抖，则不管调动多少次方法，在2s后，只会执行一次

如下图所示：

![](a2c81b50-8787-11eb-ab90-d9ae814b240d.png)

```javascript


function throttled(fn,delay){
    let timer
    return function(){
        let _this = this
        let args = arguments
        if(timer)return
        timer = setTimeoit(()=>{
                fn.apply(_this, args)
                timer = null
        },delay)
    }
}

/// 时间戳 加 定时器
function throttled(fn, delay) {
    let starttime = Date.now()
    return function () {
        let curTime = Date.now() // 当前时间
        let remaining = delay - (curTime - starttime)  // 从上一次到现在，还剩下多少多余时间
        let context = this
        let args = arguments
        clearTimeout(timer)
        if (remaining <= 0) {
            fn.apply(context, args)
            starttime = Date.now()
        }
    }
}


function debounce(func, wait, immediate) {

    let timeout;  //闭包

    return function () {
        let context = this;
        let args = arguments;

        if (timeout) clearTimeout(timeout); // timeout 不为null
        if (immediate) {
            let callNow = !timeout; // 第一次会立即执行，以后只有事件执行后才会再次触发
            timeout = setTimeout(function () {
                timeout = null;
            }, wait)
            if (callNow) {
                func.apply(context, args)
            }
        }
        else {
            timeout = setTimeout(function () {
                func.apply(context, args)
            }, wait);
        }
    }
}
```


应用场景

防抖在连续的事件，只需触发一次回调的场景有：

搜索框搜索输入。只需用户最后一次输入完，再发送请求

手机号、邮箱验证输入检测

窗口大小resize。只需窗口调整完成后，计算窗口大小。防止重复渲染。

节流在间隔一段时间执行一次回调的场景有：

滚动加载，加载更多或滚到底部监听

搜索框，搜索联想功能

6.手写-发布订阅模式

```javascript
class EventEmitter{
    constructor(){
        this.eventObj = {}
    }

    on(eventName,cb){
        if(!this.eventObj[eventName]){
            this.eventObj[eventName] = [cb]
        }else{
            this.eventObj[eventName].push(cb)
        }
    }

    // 删除订阅
    off(type, callBack) {
            if (!this.events[type]) return;
            this.events[type] = this.events[type].filter((item) => {
            return item !== callBack;
            });
    }

    emit(eventName,...args){
        this.eventObj[eventName].map(item=>item.apply(this,args))
    }
}

```

7.对称二叉树

思路： 同层节点值相等，并且左子树的值要等与右子树。
```javascript
function helper(left?: TreeNode, right?: TreeNode){
    if(!left&&!right)return true;
    if(!left || !right)return false;
    return  left.val===right.val&&helper(left.rightNode,right.leftNode)&&helper(left.leftNode,right.rightNode)
}
```